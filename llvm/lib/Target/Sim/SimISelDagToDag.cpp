//===-- SimISelDAGToDAG.cpp - A dag to dag inst selector for Sim --------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the Sim target.
//
//===----------------------------------------------------------------------===//

#include "SimTargetMachine.h"
#include "Sim.h"

#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAG.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/IR/CallingConv.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

#define DEBUG_TYPE "Sim-isel"

namespace {

class SimDAGToDAGISel : public SelectionDAGISel {
private:
    const SimSubtarget *Subtarget = nullptr;

//   const SimTargetMachine &getTargetMachine() const {
//     return static_cast<const SimTargetMachine &>(TM);
//   }

//  const SimInstrInfo *getInstrInfo() const {
//    return Subtarget->getInstrInfo();
//  }

public:
  SimDAGToDAGISel(SimTargetMachine &TM, CodeGenOpt::Level OptLevel)
      : SelectionDAGISel(TM, OptLevel) {}


    bool runOnMachineFunction(MachineFunction &MF) override {
        Subtarget = &MF.getSubtarget<SimSubtarget>();
        return SelectionDAGISel::runOnMachineFunction(MF);
    }

    // Override MachineFunctionPass.
    StringRef getPassName() const override {
        return "Sim DAG->DAG Pattern Instruction Selection";
    }

    // Override SelectionDAGISel.
    void Select(SDNode *Node) override;

    // Complex Pattern Selectors.
    bool SelectADDRrr(SDValue Addr, SDValue &Base);
    bool SelectADDRri(SDValue Addr, SDValue &Base);

// Include the pieces autogenerated from the target description.
#include "SimGenDAGISel.inc"
};
} // end anonymous namespace

FunctionPass *llvm::createSimISelDag(SimTargetMachine &TM,
                                      CodeGenOpt::Level OptLevel) {
    return new SimDAGToDAGISel(TM, OptLevel);
}

void SimDAGToDAGISel::Select(SDNode *Node) {
    // Instruction Selection not handled by the auto-generated tablegen selection
    // should be handled here.
    if (Node->isMachineOpcode()) {
        LLVM_DEBUG(dbgs() << "== "; Node->dump(CurDAG); dbgs() << "\n");
        Node->setNodeId(-1);
        return;
    }
    unsigned Opcode = Node->getOpcode();
    SDLoc DL(Node);
    MVT VT = Node->getSimpleValueType(0);

    switch (Opcode) {
        case ISD::FrameIndex: {
            SDValue Imm = CurDAG->getTargetConstant(0, DL, MVT::i32);
            int FI = cast<FrameIndexSDNode>(Node)->getIndex();
            SDValue TFI = CurDAG->getTargetFrameIndex(FI, VT);
            ReplaceNode(Node, CurDAG->getMachineNode(Sim::ADDi, DL, VT, TFI, Imm));
            return;
        }
        default:
            break;
    }

    // Select the default instruction.
    SelectCode(Node);
}

bool SimDAGToDAGISel::SelectADDRri(SDValue Addr, SDValue &Base) {
    if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
        Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
        return true;
    }
    return false;
}

bool SimDAGToDAGISel::SelectADDRrr(SDValue Addr, SDValue &Base) {
    if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
        Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
    } else {
        Base = Addr;
    }
    return true;
}
